module Axel.Haskell.Macros where
import qualified Prelude as GHCPrelude
import qualified Axel.Parse.AST as AST
import Axel.Prelude
import Axel.Haskell.Language(haskellOperatorSymbols,haskellSyntaxSymbols,isOperator)
import qualified Axel.Parse as Parse(syntaxSymbols)
import Data.List(foldl')
import Data.MonoTraversable(onotElem)
import qualified Data.Text as T
hygenisizeMacroName oldName = (let {suffix = if (isOperator oldName) then "%%%%%%%%%%" else "_AXEL_AUTOGENERATED_MACRO_DEFINITION";suffixedName = if (T.isSuffixOf suffix oldName) then oldName else ((<>) oldName suffix);symbolReplacementMap = if (isOperator oldName) then haskellSyntaxSymbols else ((<>) haskellSyntaxSymbols haskellOperatorSymbols)} in (foldl' (\acc ((,) old new) -> (T.replace (T.singleton old) new acc)) suffixedName (filter (\((,) sym _) -> (onotElem sym Parse.syntaxSymbols)) symbolReplacementMap)))
hygenisizeMacroName :: ((->) Text Text)