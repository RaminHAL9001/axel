{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE UndecidableInstances #-}

module Axel.Monad.Resource where

import Control.Monad ((>=>))
import Control.Monad.IO.Class (MonadIO, liftIO)

import Paths_axel (getDataFileName)

import System.FilePath ((</>))

import qualified System.IO.Strict as S (readFile)

newtype ResourceId =
  ResourceId String

class MonadResource m where
  getResourcePath :: ResourceId -> m FilePath
  readResource :: ResourceId -> m String

-- NOTE This is undecidable, but `mtl` uses undecidable instances in this scenario(?)....
--      Plus, I can't actually come up with a better solution.
instance (MonadIO m) => MonadResource m where
  getResourcePath :: ResourceId -> m FilePath
  getResourcePath (ResourceId resource) =
    liftIO $ getDataFileName ("resources" </> resource)
  readResource :: ResourceId -> m String
  readResource = liftIO . (getResourcePath >=> S.readFile)

astDefinition :: ResourceId
astDefinition = ResourceId "autogenerated/macros/AST.hs"

macroDefinitionAndEnvironmentHeader :: ResourceId
macroDefinitionAndEnvironmentHeader =
  ResourceId "macros/MacroDefinitionAndEnvironmentHeader.hs"

macroScaffold :: ResourceId
macroScaffold = ResourceId "macros/Scaffold.hs"

newProjectTemplate :: ResourceId
newProjectTemplate = ResourceId "new-project-template"
