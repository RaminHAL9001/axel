{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}

module Axel.Macros where

import Axel.AST
  ( Identifier
  , MacroDefinition
  , Statement(SDataDeclaration, SFunctionDefinition, SMacroDefinition,
          SModuleDeclaration, SPragma, SQualifiedImport, SRestrictedImport,
          STopLevel, STypeSignature, STypeSynonym, STypeclassInstance,
          SUnrestrictedImport)
  , ToHaskell(toHaskell)
  , functionDefinition
  , name
  , statements
  )
import Axel.Denormalize (denormalizeStatement)
import Axel.Error (Error(MacroError), mapError)
import Axel.Haskell.GHC (ghcInterpret)
import Axel.Haskell.Prettify (prettifyHaskell)
import Axel.Monad.FileSystem (MonadFileSystem)
import qualified Axel.Monad.FileSystem as FS
  ( MonadFileSystem(createDirectoryIfMissing, writeFile)
  , withCurrentDirectory
  , withTemporaryDirectory
  )
import Axel.Monad.Process (MonadProcess)
import Axel.Monad.Resource (MonadResource, readResource)
import qualified Axel.Monad.Resource as Res
  ( astDefinition
  , macroDefinitionAndEnvironmentHeader
  , macroScaffold
  )
import Axel.Normalize (normalizeStatement)
import qualified Axel.Parse as Parse
  ( Expression(LiteralChar, LiteralInt, LiteralString, SExpression,
           Symbol)
  , parseMultiple
  , programToTopLevelExpressions
  , topLevelExpressionsToProgram
  )
import Axel.Utils.Display (Delimiter(Newlines), delimit, isOperator)
import Axel.Utils.Function (uncurry3)
import Axel.Utils.Recursion
  ( Recursive(bottomUpFmap, bottomUpTraverse)
  , exhaustM
  )
import Axel.Utils.String (replace)

import Control.Lens.Cons (snoc)
import Control.Lens.Operators ((%~), (^.))
import Control.Lens.Tuple (_1, _2)
import Control.Monad (foldM)
import Control.Monad.Except (MonadError, catchError, throwError)

import Data.Function ((&))
import Data.Semigroup ((<>))

import System.FilePath ((</>))

generateMacroProgram ::
     (MonadError Error m, MonadFileSystem m, MonadResource m)
  => MacroDefinition
  -> [Statement]
  -> [Parse.Expression]
  -> m (String, String, String)
generateMacroProgram macroDef environment applicationArguments = do
  astDefinition <- readResource Res.astDefinition
  scaffold <- getScaffold
  macroDefinitionAndEnvironment <-
    (<>) <$> readResource Res.macroDefinitionAndEnvironmentHeader <*>
    getMacroDefinitionAndEnvironmentFooter
  pure (astDefinition, scaffold, macroDefinitionAndEnvironment)
  where
    getMacroDefinitionAndEnvironmentFooter = do
      hygenicMacroDefinition <-
        replaceName
          (macroDef ^. functionDefinition . name)
          newMacroName
          (SMacroDefinition macroDef)
      let source =
            prettifyHaskell $ delimit Newlines $
            map toHaskell (environment <> [hygenicMacroDefinition])
      pure source
    getScaffold :: (Monad m, MonadFileSystem m, MonadResource m) => m String
    getScaffold =
      let insertApplicationArguments =
            let applicationArgumentsPlaceholder = "%%%ARGUMENTS%%%"
             in replace
                  applicationArgumentsPlaceholder
                  (show applicationArguments)
          insertDefinitionName =
            let definitionNamePlaceholder = "%%%MACRO_NAME%%%"
             in replace definitionNamePlaceholder newMacroName
       in insertApplicationArguments . insertDefinitionName <$>
          readResource Res.macroScaffold
    newMacroName =
      (macroDef ^. functionDefinition . name) ++
      if isOperator (macroDef ^. functionDefinition . name)
        then "%%%%%%%%%%"
        else "_AXEL_AUTOGENERATED_MACRO_DEFINITION"

expansionPass ::
     (MonadError Error m, MonadFileSystem m, MonadProcess m, MonadResource m)
  => Parse.Expression
  -> m Parse.Expression
expansionPass programExpr =
  Parse.topLevelExpressionsToProgram . map denormalizeStatement <$>
  expandMacros (Parse.programToTopLevelExpressions programExpr)

programToTopLevelExpressions :: Parse.Expression -> [Parse.Expression]
programToTopLevelExpressions (Parse.SExpression (Parse.Symbol "begin":stmts)) =
  stmts
programToTopLevelExpressions _ =
  error "programToTopLevelExpressions must be passed a top-level program!"

topLevelExpressionsToProgram :: [Parse.Expression] -> Parse.Expression
topLevelExpressionsToProgram stmts =
  Parse.SExpression (Parse.Symbol "begin" : stmts)

exhaustivelyExpandMacros ::
     (MonadError Error m, MonadFileSystem m, MonadProcess m, MonadResource m)
  => Parse.Expression
  -> m Parse.Expression
exhaustivelyExpandMacros = exhaustM expansionPass

isStatementNonconflicting :: Statement -> Bool
isStatementNonconflicting (SDataDeclaration _) = True
isStatementNonconflicting (SFunctionDefinition _) = True
isStatementNonconflicting (SPragma _) = True
isStatementNonconflicting (SMacroDefinition _) = True
isStatementNonconflicting (SModuleDeclaration _) = False
isStatementNonconflicting (SQualifiedImport _) = True
isStatementNonconflicting (SRestrictedImport _) = True
isStatementNonconflicting (STopLevel _) = False
isStatementNonconflicting (STypeclassInstance _) = True
isStatementNonconflicting (STypeSignature _) = True
isStatementNonconflicting (STypeSynonym _) = True
isStatementNonconflicting (SUnrestrictedImport _) = True

expandMacros ::
     (MonadError Error m, MonadFileSystem m, MonadProcess m, MonadResource m)
  => [Parse.Expression]
  -> m [Statement]
expandMacros topLevelExprs =
  fst <$>
  foldM
    (\acc@(stmts, macroDefs) expr -> do
       expandedExpr <- fullyExpandExpr stmts macroDefs expr
       stmt <- normalizeStatement expandedExpr
       let acc' =
             case stmt of
               SMacroDefinition macroDefinition ->
                 acc & _2 %~ flip snoc macroDefinition
               _ -> acc
       pure $ acc' & _1 %~ flip snoc stmt)
    ([], [])
    topLevelExprs
  where
    fullyExpandExpr ::
         ( MonadError Error m
         , MonadFileSystem m
         , MonadProcess m
         , MonadResource m
         )
      => [Statement]
      -> [MacroDefinition]
      -> Parse.Expression
      -> m Parse.Expression
    fullyExpandExpr stmts macroDefs expr =
      exhaustM
        (bottomUpTraverse
           (\case
              Parse.SExpression xs ->
                Parse.SExpression <$>
                foldM
                  (\acc x ->
                     case x of
                       Parse.LiteralChar _ -> pure $ acc ++ [x]
                       Parse.LiteralInt _ -> pure $ acc ++ [x]
                       Parse.LiteralString _ -> pure $ acc ++ [x]
                       Parse.SExpression [] -> pure $ acc ++ [x]
                       Parse.SExpression (function:args) ->
                         lookupMacroDefinition macroDefs function >>= \case
                           Just macroDefinition ->
                             (acc ++) <$>
                             expandMacroApplication
                               macroDefinition
                               (filter isStatementNonconflicting stmts)
                               args
                           Nothing -> pure $ acc ++ [x]
                       Parse.Symbol _ -> pure $ acc ++ [x])
                  []
                  xs
              x -> pure x)) $
      Parse.topLevelExpressionsToProgram [expr]

expandMacroApplication ::
     (MonadError Error m, MonadFileSystem m, MonadProcess m, MonadResource m)
  => MacroDefinition
  -> [Statement]
  -> [Parse.Expression]
  -> m [Parse.Expression]
expandMacroApplication macroDef auxEnv args = do
  macroProgram <- generateMacroProgram macroDef auxEnv args
  newSource <- uncurry3 evalMacro macroProgram
  Parse.parseMultiple newSource

lookupMacroDefinition ::
     (MonadError Error m)
  => [MacroDefinition]
  -> Parse.Expression
  -> m (Maybe MacroDefinition)
lookupMacroDefinition macroDefs identifierExpr =
  case filter (`isMacroBeingCalled` identifierExpr) macroDefs of
    [] -> pure Nothing
    [macroDef] -> pure $ Just macroDef
    macroDef:_ ->
      throwError
        (MacroError $ "Multiple macro definitions named: `" <> macroDef ^.
         functionDefinition .
         name <>
         "`!")

isMacroBeingCalled :: MacroDefinition -> Parse.Expression -> Bool
isMacroBeingCalled macroDef identifierExpr =
  case identifierExpr of
    Parse.LiteralChar _ -> False
    Parse.LiteralInt _ -> False
    Parse.LiteralString _ -> False
    Parse.SExpression _ -> False
    Parse.Symbol identifier ->
      macroDef ^. functionDefinition . name == identifier

stripMacroDefinitions :: Statement -> Statement
stripMacroDefinitions =
  \case
    STopLevel topLevel ->
      STopLevel $
      (statements %~ filter (not . isMacroDefinitionStatement)) topLevel
    x -> x

isMacroDefinitionStatement :: Statement -> Bool
isMacroDefinitionStatement (SMacroDefinition _) = True
isMacroDefinitionStatement _ = False

replaceName ::
     (MonadError Error m)
  => Identifier
  -> Identifier
  -> Statement
  -> m Statement
replaceName oldName newName =
  normalize . bottomUpFmap replaceSymbol . denormalizeStatement
  where
    normalize expr =
      normalizeStatement expr `catchError` \_ ->
        throwError (MacroError $ "Invalid macro name: `" <> oldName <> "`!")
    replaceSymbol expr =
      case expr of
        Parse.Symbol identifier ->
          Parse.Symbol $
          if identifier == oldName
            then newName
            else identifier
        _ -> expr

evalMacro ::
     (MonadError Error m, MonadFileSystem m, MonadProcess m)
  => String
  -> String
  -> String
  -> m String
evalMacro astDefinition scaffold macroDefinitionAndEnvironment =
  FS.withTemporaryDirectory $ \directoryName ->
    FS.withCurrentDirectory directoryName $ do
      let astDirectoryPath = "Axel" </> "Parse"
      let macroDefinitionAndEnvironmentFileName =
            "MacroDefinitionAndEnvironment.hs"
      let scaffoldFileName = "Scaffold.hs"
      FS.createDirectoryIfMissing True astDirectoryPath
      FS.writeFile (astDirectoryPath </> "AST.hs") astDefinition
      FS.writeFile
        macroDefinitionAndEnvironmentFileName
        macroDefinitionAndEnvironment
      FS.writeFile scaffoldFileName scaffold
      ghcInterpret scaffoldFileName `mapError` MacroError
