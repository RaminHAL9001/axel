{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}

module Axel.Macros where

import Axel.AST
  ( Identifier
  , MacroDefinition
  , Statement(SDataDeclaration, SFunctionDefinition, SLanguagePragma,
          SMacroDefinition, SModuleDeclaration, SQualifiedImport,
          SRestrictedImport, STopLevel, STypeSynonym, STypeclassInstance,
          SUnrestrictedImport)
  , ToHaskell(toHaskell)
  , definitions
  , name
  , removeDefinitionsByName
  , statements
  )
import Axel.Denormalize (denormalizeExpression, denormalizeStatement)
import Axel.Error (Error(MacroError))
import Axel.Eval (evalMacro)
import Axel.Normalize (normalizeStatement)
import qualified Axel.Parse as Parse
  ( Expression(LiteralChar, LiteralInt, LiteralString, SExpression,
           Symbol)
  , parseMultiple
  )
import Axel.Utils.Display (Delimiter(Newlines), delimit, isOperator)
import Axel.Utils.Function (uncurry3)
import Axel.Utils.Recursion
  ( Recursive(bottomUpFmap, bottomUpTraverse)
  , exhaustM
  )
import Axel.Utils.Resources (readDataFile)
import Axel.Utils.String (replace)

import Control.Lens.Operators ((%~), (^.))
import Control.Monad (foldM)
import Control.Monad.Except (MonadError, catchError, throwError)
import Control.Monad.IO.Class (MonadIO, liftIO)
import Control.Monad.Trans.Control (MonadBaseControl)

import Data.List (foldl', partition)
import Data.Maybe (listToMaybe)
import Data.Semigroup ((<>))

import Debug.Trace (trace)

getAstDefinition :: IO String
getAstDefinition = readDataFile "autogenerated/macros/AST.hs"

generateMacroProgram ::
     (MonadBaseControl IO m, MonadError Error m, MonadIO m)
  => MacroDefinition
  -> [Statement]
  -> [Parse.Expression]
  -> m (String, String, String)
generateMacroProgram macroDefinition environment applicationArguments = do
  astDefinition <- liftIO getAstDefinition
  scaffold <- liftIO getScaffold
  macroDefinitionAndEnvironment <-
    (<>) <$> liftIO getMacroDefinitionAndEnvironmentHeader <*>
    getMacroDefinitionAndEnvironmentFooter
  pure (astDefinition, scaffold, macroDefinitionAndEnvironment)
  where
    getMacroDefinitionAndEnvironmentHeader =
      readDataFile "macros/MacroDefinitionAndEnvironmentHeader.hs"
    getMacroDefinitionAndEnvironmentFooter = do
      hygenicMacroDefinition <-
        replaceName
          (macroDefinition ^. name)
          newMacroName
          (SMacroDefinition macroDefinition)
      let source =
            delimit Newlines $
            map toHaskell (environment <> [hygenicMacroDefinition])
      pure source
    getScaffold =
      let insertApplicationArguments =
            let applicationArgumentsPlaceholder = "%%%ARGUMENTS%%%"
            in replace
                 applicationArgumentsPlaceholder
                 (show applicationArguments)
          insertDefinitionName =
            let definitionNamePlaceholder = "%%%MACRO_NAME%%%"
            in replace definitionNamePlaceholder newMacroName
      in insertApplicationArguments . insertDefinitionName <$>
         readDataFile "macros/Scaffold.hs"
    newMacroName =
      (macroDefinition ^. name) ++
      if isOperator (macroDefinition ^. name)
        then "%%%%%%%%%%"
        else "_AXEL_AUTOGENERATED_MACRO_DEFINITION"

extractIndependentStatements :: [Parse.Expression] -> [Parse.Expression]
extractIndependentStatements stmts =
  let candidateMacroDefinitions = filter isMacroDefinition stmts
  in filter (not . isDependentOnAny candidateMacroDefinitions) stmts
  where
    isMacroDefinition (Parse.SExpression (Parse.Symbol "defmacro":_)) = True
    isMacroDefinition _ = False
    macroNameFromDefinition (Parse.SExpression (Parse.Symbol "defmacro":Parse.Symbol macroName:_)) =
      macroName
    macroNameFromDefinition _ =
      error
        "macroNameFromDefinition should only be called with a valid macro definition!"
    isDependentOn macroDef (Parse.SExpression (Parse.Symbol symbol:exprs)) =
      macroNameFromDefinition macroDef == symbol ||
      any (isDependentOn macroDef) exprs
    isDependentOn macroDef (Parse.SExpression exprs) =
      any (isDependentOn macroDef) exprs
    isDependentOn _ _ = False
    isDependentOnAny macroDefs expr = any (`isDependentOn` expr) macroDefs

expansionPass ::
     (MonadBaseControl IO m, MonadError Error m, MonadIO m)
  => Parse.Expression
  -> m Parse.Expression
expansionPass programExpr = do
  let independentStmts =
        extractIndependentStatements $ programToStmts programExpr
  normalizedStmts <- traverse normalizeStatement independentStmts
  let nonconflictingStmts = filter canInclude normalizedStmts
  let maybeFirstMacroDef =
        listToMaybe $ filter isMacroDefinitionStatement nonconflictingStmts
  case maybeFirstMacroDef of
    Just (SMacroDefinition firstMacroDef) ->
      let otherStmts =
            filter (/= SMacroDefinition firstMacroDef) nonconflictingStmts
      in expandMacro
           (trace (toHaskell $ SMacroDefinition firstMacroDef) firstMacroDef)
           otherStmts
           programExpr
    _ -> pure programExpr
  where
    canInclude :: Statement -> Bool
    canInclude =
      \case
        SDataDeclaration _ -> True
        SFunctionDefinition _ -> True
        SLanguagePragma _ -> True
        SMacroDefinition _ -> True
        SModuleDeclaration _ -> False
        SQualifiedImport _ -> True
        SRestrictedImport _ -> True
        STopLevel _ -> False
        STypeclassInstance _ -> True
        STypeSynonym _ -> True
        SUnrestrictedImport _ -> True
    programToStmts :: Parse.Expression -> [Parse.Expression]
    programToStmts (Parse.SExpression (Parse.Symbol "begin":stmts)) = stmts
    programToStmts _ =
      error "programToStmts must be passed a top-level program!"

exhaustivelyExpandMacros ::
     (MonadBaseControl IO m, MonadError Error m, MonadIO m)
  => Parse.Expression
  -> m Parse.Expression
exhaustivelyExpandMacros = exhaustM expansionPass

-- TODO This needs heavy optimization.
expandMacro ::
     (MonadBaseControl IO m, MonadError Error m, MonadIO m)
  => MacroDefinition
  -> [Statement]
  -> Parse.Expression
  -> m Parse.Expression
expandMacro macroDef auxEnv =
  bottomUpTraverse $ \expr ->
    case expr of
      Parse.LiteralChar _ -> pure expr
      Parse.LiteralInt _ -> pure expr
      Parse.LiteralString _ -> pure expr
      Parse.SExpression xs ->
        Parse.SExpression <$>
        foldM
          (\acc x ->
             case x of
               Parse.LiteralChar _ -> pure $ acc ++ [x]
               Parse.LiteralInt _ -> pure $ acc ++ [x]
               Parse.LiteralString _ -> pure $ acc ++ [x]
               Parse.SExpression [] -> pure $ acc ++ [x]
               Parse.SExpression (function:args) ->
                 if isMacroBeingCalled macroDef function
                   then (acc ++) <$> expandMacroApplication macroDef auxEnv args
                   else pure $ acc ++ [x]
               Parse.Symbol _ -> pure $ acc ++ [x])
          []
          xs
      Parse.Symbol _ -> pure expr

expandMacroApplication ::
     (MonadBaseControl IO m, MonadError Error m, MonadIO m)
  => MacroDefinition
  -> [Statement]
  -> [Parse.Expression]
  -> m [Parse.Expression]
expandMacroApplication macroDef rawAuxEnv args = do
  auxEnv <-
    exhaustM pruneEnv $ filter (not . isMacroDefinitionStatement) rawAuxEnv
  result <- runMacro auxEnv
  case result of
    Right x -> Parse.parseMultiple x
    Left (stderr, _) -> throwError $ MacroError stderr
  where
    pruneEnv auxEnv = do
      result <- runMacro auxEnv
      pure $
        case result of
          Right _ -> auxEnv
          Left (_, invalidDefs) -> removeDefinitionsByName invalidDefs auxEnv
    runMacro auxEnv = do
      macroProgram <- generateMacroProgram macroDef auxEnv args
      uncurry3 evalMacro macroProgram

isMacroBeingCalled :: MacroDefinition -> Parse.Expression -> Bool
isMacroBeingCalled macroDef identifierExpr =
  case identifierExpr of
    Parse.LiteralChar _ -> False
    Parse.LiteralInt _ -> False
    Parse.LiteralString _ -> False
    Parse.SExpression _ -> False
    Parse.Symbol identifier -> macroDef ^. name == identifier

-- TODO This probably needs heavy optimization. If so, I will need to decrease the running time.
extractMacroDefinitions :: Statement -> [MacroDefinition]
extractMacroDefinitions (STopLevel topLevel) =
  foldl'
    (\env stmt ->
       case stmt of
         SMacroDefinition macroDef ->
           let newEnv = macroDef : env
               isDependentOnNewEnv x =
                 any (`isDefinitionDependentOnMacro` x) newEnv
           in filter (not . isDependentOnNewEnv) newEnv
         _ -> env)
    []
    (topLevel ^. statements)
extractMacroDefinitions _ = []

isDefinitionDependentOnMacro :: MacroDefinition -> MacroDefinition -> Bool
isDefinitionDependentOnMacro needle haystack =
  let definitionBodies = map snd (haystack ^. definitions)
  in any
       (isExpressionDependentOnMacro needle)
       (map denormalizeExpression definitionBodies)

isExpressionDependentOnMacro :: MacroDefinition -> Parse.Expression -> Bool
isExpressionDependentOnMacro _ (Parse.LiteralChar _) = False
isExpressionDependentOnMacro _ (Parse.LiteralInt _) = False
isExpressionDependentOnMacro _ (Parse.LiteralString _) = False
isExpressionDependentOnMacro needle (Parse.SExpression xs) =
  any (isExpressionDependentOnMacro needle) xs
isExpressionDependentOnMacro needle (Parse.Symbol x) = x == needle ^. name

stripMacroDefinitions :: Statement -> Statement
stripMacroDefinitions =
  \case
    STopLevel topLevel ->
      STopLevel $
      (statements %~ filter (not . isMacroDefinitionStatement)) topLevel
    x -> x

isMacroDefinitionStatement :: Statement -> Bool
isMacroDefinitionStatement (SMacroDefinition _) = True
isMacroDefinitionStatement _ = False

replaceName ::
     (MonadError Error m)
  => Identifier
  -> Identifier
  -> Statement
  -> m Statement
replaceName oldName newName =
  normalize . bottomUpFmap replaceSymbol . denormalizeStatement
  where
    normalize expr =
      normalizeStatement expr `catchError` \_ ->
        throwError (MacroError $ "Invalid macro name: `" <> oldName <> "`!")
    replaceSymbol expr =
      case expr of
        Parse.Symbol identifier ->
          Parse.Symbol $
          if identifier == oldName
            then newName
            else identifier
        _ -> expr
