{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}

module Axel.Macros where

import Axel.AST
  ( MacroDefinition
  , Statement(SMacroDefinition, STopLevel)
  , ToHaskell(toHaskell)
  , definitions
  , name
  , statements
  )
import Axel.Error (Error(MacroError))
import Axel.Eval (evalSource)
import Axel.Normalize (denormalizeExpression, normalizeProgram)
import qualified Axel.Parse as Parse
  ( Expression(LiteralChar, LiteralInt, LiteralString, SExpression,
           Symbol)
  , parseMultiple
  )
import Axel.Utils.Display (isOperator)
import Axel.Utils.Recursion (Recursive(bottomUpTraverse), exhaustM)
import Axel.Utils.Resources (readDataFile)
import Axel.Utils.String (replace)

import Control.Lens.Operators ((%~), (.~), (^.))
import Control.Monad (foldM)
import Control.Monad.Except (MonadError, throwError)
import Control.Monad.IO.Class (MonadIO, liftIO)

import Data.List (foldl')
import Data.Semigroup ((<>))

getAstDefinition :: IO String
getAstDefinition = readDataFile "autogenerated/macros/Header.hs"

generateMacroProgram ::
     (MonadIO m) => MacroDefinition -> [Parse.Expression] -> m String
generateMacroProgram macroDefinition applicationArguments =
  (<>) <$> liftIO getFileHeader <*> liftIO getFileFooter
  where
    getFileHeader = getAstDefinition
    getFileFooter =
      let insertApplicationArguments =
            let applicationArgumentsPlaceholder = "%%%ARGUMENTS%%%"
            in replace
                 applicationArgumentsPlaceholder
                 (show applicationArguments)
          insertDefinitionBody =
            let definitionBodyPlaceholder = "%%%MACRO_DEFINITION%%%"
            in replace
                 definitionBodyPlaceholder
                 (toHaskell $ (name .~ newMacroName) macroDefinition)
          insertDefinitionName =
            let definitionNamePlaceholder = "%%%MACRO_NAME%%%"
            in replace definitionNamePlaceholder newMacroName
      in insertApplicationArguments .
         insertDefinitionName . insertDefinitionBody <$>
         readDataFile "macros/Footer.hs"
    newMacroName =
      (macroDefinition ^. name) ++
      if isOperator (macroDefinition ^. name)
        then "%%%%%%%%%%"
        else "_AXEL_AUTOGENERATED_MACRO_DEFINITION"

exhaustivelyExpandMacros ::
     (MonadError Error m, MonadIO m) => Parse.Expression -> m Parse.Expression
exhaustivelyExpandMacros = exhaustM expansionPass
  where
    expansionPass x = do
      macroDefinitions <- extractMacroDefinitions <$> normalizeProgram x
      expandMacros macroDefinitions x

expandMacros ::
     (MonadError Error m, MonadIO m)
  => [MacroDefinition]
  -> Parse.Expression
  -> m Parse.Expression
expandMacros environment =
  bottomUpTraverse $ \expression ->
    case expression of
      Parse.LiteralChar _ -> return expression
      Parse.LiteralInt _ -> return expression
      Parse.LiteralString _ -> return expression
      Parse.SExpression xs ->
        Parse.SExpression <$>
        foldM
          (\acc x ->
             case x of
               Parse.LiteralChar _ -> return $ acc ++ [x]
               Parse.LiteralInt _ -> return $ acc ++ [x]
               Parse.LiteralString _ -> return $ acc ++ [x]
               Parse.SExpression [] -> return $ acc ++ [x]
               Parse.SExpression (function:args) ->
                 lookupMacroDefinition environment function >>= \case
                   Just macroDefinition ->
                     (acc ++) <$> expandMacroApplication macroDefinition args
                   Nothing -> return $ acc ++ [x]
               Parse.Symbol _ -> return $ acc ++ [x])
          []
          xs
      Parse.Symbol _ -> return expression
  where
    expandMacroApplication macroDefinition args =
      generateMacroProgram macroDefinition args >>= evalSource >>=
      Parse.parseMultiple

lookupMacroDefinition ::
     (MonadError Error m)
  => [MacroDefinition]
  -> Parse.Expression
  -> m (Maybe MacroDefinition)
lookupMacroDefinition environment identifierExpression =
  case identifierExpression of
    Parse.LiteralChar _ -> return Nothing
    Parse.LiteralInt _ -> return Nothing
    Parse.LiteralString _ -> return Nothing
    Parse.SExpression _ -> return Nothing
    Parse.Symbol identifier ->
      case filter
             (\macroDefinition -> macroDefinition ^. name == identifier)
             environment of
        [] -> return Nothing
        [macroDefinition] -> return $ Just macroDefinition
        _ -> throwError (MacroError "0012")

-- TODO This probably needs heavy optimization. If so, I will need to decrease the running time.
extractMacroDefinitions :: Statement -> [MacroDefinition]
extractMacroDefinitions (STopLevel topLevel) =
  foldl'
    (\env statement ->
       case statement of
         SMacroDefinition macroDefinition ->
           let newEnv = macroDefinition : env
               isDependentOnNewEnv x =
                 any (`isDefinitionDependentOnMacro` x) newEnv
           in filter (not . isDependentOnNewEnv) newEnv
         _ -> env)
    []
    (topLevel ^. statements)
extractMacroDefinitions _ = []

isDefinitionDependentOnMacro :: MacroDefinition -> MacroDefinition -> Bool
isDefinitionDependentOnMacro needle haystack =
  let definitionBodies = map snd (haystack ^. definitions)
  in any
       (isExpressionDependentOnMacro needle)
       (map denormalizeExpression definitionBodies)

isExpressionDependentOnMacro :: MacroDefinition -> Parse.Expression -> Bool
isExpressionDependentOnMacro _ (Parse.LiteralChar _) = False
isExpressionDependentOnMacro _ (Parse.LiteralInt _) = False
isExpressionDependentOnMacro _ (Parse.LiteralString _) = False
isExpressionDependentOnMacro needle (Parse.SExpression xs) =
  any (isExpressionDependentOnMacro needle) xs
isExpressionDependentOnMacro needle (Parse.Symbol x) = x == needle ^. name

stripMacroDefinitions :: Statement -> Statement
stripMacroDefinitions x =
  case x of
    STopLevel topLevel ->
      STopLevel $ (statements %~ filter (not . isMacroDefinition)) topLevel
    _ -> x
  where
    isMacroDefinition (SMacroDefinition _) = True
    isMacroDefinition _ = False
