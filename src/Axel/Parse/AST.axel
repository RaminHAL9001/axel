(pragma "LANGUAGE FlexibleInstances")
(pragma "LANGUAGE InstanceSigs")

-- NOTE Because this file will be used as the header of auto-generated macro programs,
--      it can't have any project-specific dependencies (such as `Fix`).
(module Axel.Parse.AST)

(import Data.IORef (IORef modifyIORef newIORef readIORef))
(import Data.Semigroup (<>))

(import System.IO.Unsafe (unsafePerformIO))

-- PRELUDE_BEGIN
(macro quasiquote ([(AST.SExpression xs)])
       (let ((quasiquoteElem (\ (x) (case x
                                      ((AST.SExpression ['unquote x])
                                       (AST.SExpression ['list x]))
                                      ((AST.SExpression ['unquoteSplicing x])
                                       (AST.SExpression ['AST.toExpressionList x]))
                                      (atom
                                       (AST.SExpression
                                        ['list
                                         (AST.SExpression ['quasiquote atom])]))))))
         (pure [(AST.SExpression ['AST.SExpression (AST.SExpression ['concat (AST.SExpression (: 'list (map quasiquoteElem xs)))])])])))
(macro quasiquote ([atom])
       (pure [(AST.SExpression ['quote atom])]))

(macro applyInfix ([x op y])
       (pure [`(~op ~x ~y)]))

(macro fnCase (cases)
       (<$> (\ (varId)
             [`(\ (~varId) (case ~varId ~@cases))])
            AST.gensym))

(macro def ({name : {typeSig : cases}})
       (pure
        (: `(:: ~name ~typeSig)
           (map (\ (x) `(= ~name ~@x))
                cases))))

(def mdo' {(List AST.Expression) -> AST.Expression}
  (({var : {'<- : {val : rest}}})
   `(>>= ~val (\ (~var) ~(mdo' rest))))
  (((: val rest))
   (case rest
     ([]
      val)
     (_
      `(>> ~val ~(mdo' rest))))))

(macro mdo (input)
       (pure [(mdo' input)]))

(macro if ([cond true false])
       (pure [`(case ~cond
                 (True ~true)
                 (False ~false))]))
-- PRELUDE_END

-- TODO `Expression` should probably be `Traversable`, use recursion schemes, etc.
--      I should provide `toFix` and `fromFix` functions for macros to take advantage of.
--      (Maybe all macros have the argument automatically `fromFix`-ed to make consumption simpler?)
(data Expression
      (LiteralChar Char)
      (LiteralInt Int)
      (LiteralString String)
      (SExpression [Expression])
      (Symbol String))
  deriving (Eq, Show)

-- ******************************
-- Internal utilities
-- ******************************
(def toAxel {Expression -> String}
  (((LiteralChar x)) [#\{ x #\}])
  (((LiteralInt x)) (show x))
  (((LiteralString xs)) {"\"" <> {xs <> "\""}})
  (((SExpression xs)) {"(" <> {(unwords (map toAxel xs)) <> ")"}})
  (((Symbol x)) x))

-- ******************************
-- Macro definition utilities
-- ******************************
(pragma "NOINLINE gensymCounter")
(def gensymCounter (IORef Int)
  (() (unsafePerformIO (newIORef 0))))

(def gensym (IO Expression)
  (() (mdo
       <- readIORef gensymCounter
       (let ((identifier {"aXEL_AUTOGENERATED_IDENTIFIER_" <> (show suffix)}))
         (mdo
          (modifyIORef gensymCounter succ)
          (pure (Symbol identifier)))))))

-- | This allows splice-unquoting of both `[Expression]`s and `SExpression`s, without requiring special syntax for each.
(class () (ToExpressionList a)
       (:: toExpressionList {a -> [Expression]}))

(instance () (ToExpressionList [Expression])
          (:: toExpressionList {[Expression] -> [Expression]})
          (= toExpressionList (() id)))

-- | Because we do not have a way to statically ensure an `SExpression` is passed (and not another one of `Expression`'s constructors instead), we will error at compile-time if a macro attempts to splice-unquote inappropriately.
(instance () (ToExpressionList Expression)
          (def toExpressionList {Expression -> [Expression]}
            (((SExpression xs)) xs)
            ((x) error {(show x) <> " cannot be splice-unquoted, because it is not an s-expression!"})))
