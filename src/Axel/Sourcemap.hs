{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Axel.Sourcemap where

import Axel.Eff.Loop (breakLoop)
import qualified Axel.Eff.Loop as Effs (runLoop)
import qualified Axel.Error as Error (Error)
import qualified Axel.Parse.AST as Parse
  ( Expression
  , SourceMetadata(AutoGenerated)
  )
import Axel.Parse.AST (SourcePosition(SourcePosition, column, line))
import Axel.Utils.Foldable (intercalate)
import Axel.Utils.Tuple (Annotated, annotate, annotation, unannotate)

import Control.Lens.Operators ((^.))
import Control.Lens.TH (makeWrapped)
import Control.Monad (forM_, when)
import qualified Control.Monad.Freer as Effs (run)
import Control.Monad.Freer.State (get, put)
import qualified Control.Monad.Freer.State as Effs (evalState)

newtype Output =
  Output [Annotated Parse.SourceMetadata String]

deriving instance Semigroup Output

deriving instance Monoid Output

makeWrapped ''Output

raw :: Output -> String
raw (Output output) = concatMap unannotate output

unassociated :: String -> Output
unassociated x = Output [annotate Parse.AutoGenerated x]

type Error = Error.Error Parse.SourceMetadata

type Expression = Parse.Expression Parse.SourceMetadata

data Bracket
  = CurlyBraces
  | DoubleQuotes
  | Parentheses
  | SingleQuotes
  | SquareBrackets

surround :: Bracket -> Output -> Output
surround bracket x =
  let (open, closed) =
        case bracket of
          CurlyBraces -> ("{", "}")
          DoubleQuotes -> ("\"", "\"")
          Parentheses -> ("(", ")")
          SingleQuotes -> ("'", "'")
          SquareBrackets -> ("[", "]")
   in unassociated open <> x <> unassociated closed

data Delimiter
  = Commas
  | Newlines
  | Pipes
  | Semicolons
  | Spaces

delimit :: Delimiter -> [Output] -> Output
delimit delimiter = intercalate (unassociated $ renderDelimiter delimiter)
  where
    renderDelimiter Commas = ","
    renderDelimiter Newlines = "\n"
    renderDelimiter Pipes = "|"
    renderDelimiter Semicolons = ";"
    renderDelimiter Spaces = " "

renderBlock :: [Output] -> Output
renderBlock = surround CurlyBraces . delimit Semicolons

-- | Given a position in some transpiled output, find the corresponding
--   metadata in the original source.
--   Behavior is undefined if `column transPos == 0`.
--   TODO Make algorithm functional (assuming this can be cleanly done so).
findOrigPos :: [Annotated ann String] -> SourcePosition -> Maybe ann
findOrigPos output transPos =
  Effs.run $
  Effs.evalState (SourcePosition {line = 1, column = 0}) $
  Effs.runLoop $ do
    forM_ output $ \chunk ->
      forM_ (unannotate chunk) $ \char -> do
        oldSrcPos <- get
        let newSrcPos =
              if char == '\n'
                then SourcePosition {line = succ (line oldSrcPos), column = 0}
                else oldSrcPos {column = succ (column oldSrcPos)}
        when (newSrcPos == transPos) $ breakLoop (Just $ chunk ^. annotation)
        put newSrcPos
    pure Nothing
