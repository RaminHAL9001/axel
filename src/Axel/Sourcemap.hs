{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}

module Axel.Sourcemap where

import qualified Axel.Error as Error (Error)
import qualified Axel.Parse.AST as Parse
  ( Expression
  , SourceMetadata(AutoGenerated)
  )
import Axel.Utils.Foldable (intercalate)

import Control.Lens.TH (makeWrapped)

newtype Output =
  Output [(Parse.SourceMetadata, String)]

deriving instance Semigroup Output

deriving instance Monoid Output

makeWrapped ''Output

raw :: Output -> String
raw (Output output) = concatMap snd output

unassociated :: String -> Output
unassociated x = Output [(Parse.AutoGenerated, x)]

type Error = Error.Error Parse.SourceMetadata

type Expression = Parse.Expression Parse.SourceMetadata

data Bracket
  = CurlyBraces
  | DoubleQuotes
  | Parentheses
  | SingleQuotes
  | SquareBrackets

surround :: Bracket -> Output -> Output
surround bracket x =
  let (open, closed) =
        case bracket of
          CurlyBraces -> ("{", "}")
          DoubleQuotes -> ("\"", "\"")
          Parentheses -> ("(", ")")
          SingleQuotes -> ("'", "'")
          SquareBrackets -> ("[", "]")
   in unassociated open <> x <> unassociated closed

data Delimiter
  = Commas
  | Newlines
  | Pipes
  | Semicolons
  | Spaces

delimit :: Delimiter -> [Output] -> Output
delimit delimiter = intercalate (unassociated $ renderDelimiter delimiter)
  where
    renderDelimiter Commas = ","
    renderDelimiter Newlines = "\n"
    renderDelimiter Pipes = "|"
    renderDelimiter Semicolons = ";"
    renderDelimiter Spaces = " "

renderBlock :: [Output] -> Output
renderBlock = surround CurlyBraces . delimit Semicolons
