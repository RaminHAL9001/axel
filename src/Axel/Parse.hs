-- NOTE Because `Axel.Parse.AST` will be used as the header of auto-generated macro programs,
--      it can't have any project-specific dependencies. As such, the instance definition for
--      `BottomUp Expression` can't be defined in the same file as `Expression` itself
--      (due to the dependency on `BottomUp`). Fortunately, `Axel.Parse.AST` will (should)
--      never be imported by itself but only implicitly as part of this module.
{-# OPTIONS_GHC -fno-warn-orphans #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeApplications #-}

module Axel.Parse
  ( module Axel.Parse
  , module Axel.Parse.AST
  ) where

import Axel.Error (Error(ParseError), fatal, unsafeIgnoreError)

-- Re-exporting these so that consumers of parsed ASTs do not need
-- to know about the internal file.
import Axel.Haskell.Language (haskellOperatorSymbols, haskellSyntaxSymbols)
import Axel.Parse.AST
  ( Expression(LiteralChar, LiteralInt, LiteralString, SExpression,
           Symbol)
  , SourceMetadata(AutoGenerated, FromSource)
  , SourcePosition(SourcePosition, column, line)
  )
import qualified Axel.Sourcemap as SM (Error, Expression)
import Axel.Utils.List (takeUntil)
import Axel.Utils.Recursion
  ( Recursive(bottomUpFmap, bottomUpTraverse, topDownFmap)
  )

import Control.Monad.Freer (Eff, Member)
import Control.Monad.Freer.Error (throwError)
import qualified Control.Monad.Freer.Error as Effs (Error)

import Data.Functor.Identity (Identity)
import Data.List ((\\))

import Text.Parsec (ParsecT, Stream, (<|>), eof, parse, try)
import Text.Parsec.Char (alphaNum, char, digit, noneOf, oneOf, space, string)
import Text.Parsec.Combinator (many1, optional)
import Text.Parsec.Language (haskellDef)
import Text.Parsec.Pos (sourceColumn, sourceLine)
import Text.Parsec.Prim (getPosition, many)
import Text.Parsec.Token (makeTokenParser, stringLiteral)

-- TODO `Expression` should probably instead be an instance of `Traversable`, use recursion schemes, etc.
--      If so, should I provide `toFix` and `fromFix` functions for macros to take advantage of?
--      (Maybe all macros have the argument automatically `fromFix`-ed to make consumption simpler?)
instance Recursive (Expression ann) where
  bottomUpFmap ::
       (Expression ann -> Expression ann) -> Expression ann -> Expression ann
  bottomUpFmap f x =
    f $
    case x of
      LiteralChar _ _ -> x
      LiteralInt _ _ -> x
      LiteralString _ _ -> x
      SExpression ann' xs -> SExpression ann' (map (bottomUpFmap f) xs)
      Symbol _ _ -> x
  bottomUpTraverse ::
       (Monad m)
    => (Expression ann -> m (Expression ann))
    -> Expression ann
    -> m (Expression ann)
  bottomUpTraverse f x =
    f =<<
    case x of
      LiteralChar _ _ -> pure x
      LiteralInt _ _ -> pure x
      LiteralString _ _ -> pure x
      SExpression ann' xs ->
        SExpression ann' <$> traverse (bottomUpTraverse f) xs
      Symbol _ _ -> pure x
  topDownFmap ::
       (Expression ann -> Expression ann) -> Expression ann -> Expression ann
  topDownFmap f x =
    case f x of
      LiteralChar _ _ -> x
      LiteralInt _ _ -> x
      LiteralString _ _ -> x
      SExpression ann' xs -> SExpression ann' (map (topDownFmap f) xs)
      Symbol _ _ -> x

ann ::
     (Monad m)
  => (SourceMetadata -> a -> b)
  -> ParsecT s u m a
  -> ParsecT s u m b
ann f x = do
  parsecPosition <- getPosition
  let sourcePosition =
        SourcePosition
          { line = sourceLine parsecPosition
          , column = sourceColumn parsecPosition
          }
  f (FromSource sourcePosition) <$> x

parseReadMacro :: String -> String -> ParsecT String u Identity SM.Expression
parseReadMacro prefix wrapper = do
  expr <- string prefix *> expression
  ann SExpression (pure [Symbol AutoGenerated wrapper, expr])

any' :: (Stream s m Char) => ParsecT s u m Char
any' = noneOf ""

whitespace :: (Stream s m Char) => ParsecT s u m String
whitespace = many space

literalChar :: (Stream s m Char) => ParsecT s u m SM.Expression
literalChar = ann LiteralChar (string "#\\" *> any')

literalInt :: (Stream s m Char) => ParsecT s u m SM.Expression
literalInt = ann LiteralInt (read <$> many1 digit)

literalList :: ParsecT String u Identity SM.Expression
literalList =
  ann
    SExpression
    ((Symbol AutoGenerated "list" :) <$> (char '[' *> many item <* char ']'))
  where
    item = try (whitespace *> expression) <|> expression

literalString :: ParsecT String u Identity SM.Expression
literalString = ann LiteralString (stringLiteral (makeTokenParser haskellDef))

quasiquotedExpression :: ParsecT String u Identity SM.Expression
quasiquotedExpression = parseReadMacro "`" "quasiquote"

quotedExpression :: ParsecT String u Identity SM.Expression
quotedExpression = parseReadMacro "'" "quote"

sExpressionItem :: ParsecT String u Identity SM.Expression
sExpressionItem = try (whitespace *> expression) <|> expression

sExpression :: ParsecT String u Identity SM.Expression
sExpression = ann SExpression (char '(' *> many sExpressionItem <* char ')')

infixSExpression :: ParsecT String u Identity SM.Expression
infixSExpression =
  ann
    SExpression
    ((Symbol AutoGenerated "applyInfix" :) <$>
     (char '{' *> many sExpressionItem <* char '}'))

spliceUnquotedExpression :: ParsecT String u Identity SM.Expression
spliceUnquotedExpression = parseReadMacro "~@" "unquoteSplicing"

symbol :: (Stream s Identity Char) => ParsecT s u Identity SM.Expression
symbol =
  ann
    Symbol
    (many1
       (alphaNum <|> oneOf "'_" <|>
        oneOf (map fst haskellSyntaxSymbols \\ syntaxSymbols) <|>
        oneOf (map fst haskellOperatorSymbols)))

unquotedExpression :: ParsecT String u Identity SM.Expression
unquotedExpression = parseReadMacro "~" "unquote"

expression :: ParsecT String u Identity SM.Expression
expression =
  literalChar <|> literalInt <|> literalList <|> literalString <|>
  quotedExpression <|>
  quasiquotedExpression <|>
  try spliceUnquotedExpression <|>
  unquotedExpression <|>
  sExpression <|>
  infixSExpression <|>
  symbol

-- TODO Derive this with Template Haskell (it's really brittle, currently).
quoteParseExpression :: Expression SourceMetadata -> Expression SourceMetadata
quoteParseExpression (LiteralChar _ x) =
  SExpression
    AutoGenerated
    [ Symbol AutoGenerated "AST.LiteralChar"
    , Symbol AutoGenerated "AST.AutoGenerated"
    , LiteralChar AutoGenerated x
    ]
quoteParseExpression (LiteralInt _ x) =
  SExpression
    AutoGenerated
    [ Symbol AutoGenerated "AST.LiteralInt"
    , Symbol AutoGenerated "AST.AutoGenerated"
    , LiteralInt AutoGenerated x
    ]
quoteParseExpression (LiteralString _ x) =
  SExpression
    AutoGenerated
    [ Symbol AutoGenerated "AST.LiteralString"
    , Symbol AutoGenerated "AST.AutoGenerated"
    , LiteralString AutoGenerated x
    ]
quoteParseExpression (SExpression _ xs) =
  SExpression
    AutoGenerated
    [ Symbol AutoGenerated "AST.SExpression"
    , Symbol AutoGenerated "AST.AutoGenerated"
    , SExpression
        AutoGenerated
        (Symbol AutoGenerated "list" : map quoteParseExpression xs)
    ]
quoteParseExpression (Symbol _ x) =
  SExpression
    AutoGenerated
    [ Symbol AutoGenerated "AST.Symbol"
    , Symbol AutoGenerated "AST.AutoGenerated"
    , LiteralString AutoGenerated (handleEscapes x)
    ]
  where
    handleEscapes =
      concatMap $ \case
        '\\' -> "\\\\"
        c -> [c]

parseMultiple ::
     (Member (Effs.Error SM.Error) effs) => String -> Eff effs [SM.Expression]
parseMultiple input =
  case parse
         (many1 (optional whitespace *> expression <* optional whitespace) <*
          eof)
         ""
         input of
    Right exprs -> pure $ map expandQuotes exprs
    Left err -> throwError (ParseError (show err) :: SM.Error)
  where
    expandQuotes =
      topDownFmap
        (\case
           SExpression _ [Symbol _ "quote", x] -> quoteParseExpression x
           x -> x)

-- | Will error at runtime if any are true:
--    * A parse error occurs.
--    * Multiple statements were able to be parsed.
unsafeParseSingle :: String -> SM.Expression
unsafeParseSingle = head . unsafeIgnoreError @SM.Error . parseMultiple

stripComments :: String -> String
stripComments = unlines . map cleanLine . lines
  where
    cleanLine = takeUntil "--"

parseSource ::
     (Member (Effs.Error SM.Error) effs) => String -> Eff effs SM.Expression
parseSource input = do
  statements <- parseMultiple $ stripComments input
  pure $ topLevelExpressionsToProgram statements

programToTopLevelExpressions :: SM.Expression -> [SM.Expression]
programToTopLevelExpressions (SExpression _ (Symbol _ "begin":stmts)) = stmts
programToTopLevelExpressions _ = fatal "programToTopLevelExpressions" "0001"

topLevelExpressionsToProgram :: [SM.Expression] -> SM.Expression
topLevelExpressionsToProgram stmts =
  SExpression AutoGenerated (Symbol AutoGenerated "begin" : stmts)

syntaxSymbols :: String
syntaxSymbols = "()[]{}"
