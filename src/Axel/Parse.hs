-- NOTE Because `Axel.Parse.AST` will be used as the header of auto-generated macro programs,
--      it can't have any project-specific dependencies. As such, the instance definition for
--      `BottomUp Expression` can't be defined in the same file as `Expression` itself
--      (due to the dependency on `BottomUp`). Fortunately, `Axel.Parse.AST` will (should)
--      never be imported by itself but only implicitly as part of this module.
{-# OPTIONS_GHC -fno-warn-orphans #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}

module Axel.Parse
  ( module Axel.Parse
  , module Axel.Parse.AST
  ) where

import Axel.Error (Error(ParseError), fatal, unsafeIgnoreError)

-- Re-exporting these so that consumers of parsed ASTs do not need
-- to know about the internal file.
import Axel.Haskell.Language (haskellOperatorSymbols, haskellSyntaxSymbols)
import Axel.Parse.AST -- We want to re-export everything
import qualified Axel.Sourcemap as SM (Error, Expression)
import Axel.Utils.List (takeUntil)
import qualified Axel.Utils.Recursion as Rec
  ( Recursive(bottomUpFmap, bottomUpTraverse, topDownFmap)
  )

import Control.Lens.TH (makeFieldsNoPrefix)
import Control.Monad.Freer (Eff, Member)
import Control.Monad.Freer.Error (throwError)
import qualified Control.Monad.Freer.Error as Effs (Error)

import Data.Functor.Identity (Identity)
import Data.List ((\\))

import Text.Parsec (ParsecT, Stream, (<|>), eof, parse, try)
import Text.Parsec.Char (alphaNum, char, digit, noneOf, oneOf, space, string)
import Text.Parsec.Combinator (many1, optional)
import Text.Parsec.Language (haskellDef)
import Text.Parsec.Pos (sourceColumn, sourceLine)
import Text.Parsec.Prim (getPosition, many)
import Text.Parsec.Token (makeTokenParser, stringLiteral)

makeFieldsNoPrefix ''SourcePosition

instance Rec.Recursive (Expression ann) where
  bottomUpFmap = bottomUpFmap
  bottomUpTraverse = bottomUpTraverse
  topDownFmap = topDownFmap

ann ::
     (Monad m)
  => (SourceMetadata -> a -> b)
  -> ParsecT s u m a
  -> ParsecT s u m b
ann f x = do
  parsecPosition <- getPosition
  let sourcePosition =
        SourcePosition
          { line = sourceLine parsecPosition
          , column = sourceColumn parsecPosition
          }
  f (FromSource sourcePosition) <$> x

parseReadMacro :: String -> String -> ParsecT String u Identity SM.Expression
parseReadMacro prefix wrapper = do
  expr <- string prefix *> expression
  ann SExpression (pure [Symbol AutoGenerated wrapper, expr])

any' :: (Stream s m Char) => ParsecT s u m Char
any' = noneOf ""

whitespace :: (Stream s m Char) => ParsecT s u m String
whitespace = many space

literalChar :: (Stream s m Char) => ParsecT s u m SM.Expression
literalChar = ann LiteralChar (string "#\\" *> any')

literalInt :: (Stream s m Char) => ParsecT s u m SM.Expression
literalInt = ann LiteralInt (read <$> many1 digit)

literalList :: ParsecT String u Identity SM.Expression
literalList =
  ann
    SExpression
    ((Symbol AutoGenerated "list" :) <$> (char '[' *> many item <* char ']'))
  where
    item = try (whitespace *> expression) <|> expression

literalString :: ParsecT String u Identity SM.Expression
literalString = ann LiteralString (stringLiteral (makeTokenParser haskellDef))

quasiquotedExpression :: ParsecT String u Identity SM.Expression
quasiquotedExpression = parseReadMacro "`" "quasiquote"

quotedExpression :: ParsecT String u Identity SM.Expression
quotedExpression = parseReadMacro "'" "quote"

sExpressionItem :: ParsecT String u Identity SM.Expression
sExpressionItem = try (whitespace *> expression) <|> expression

sExpression :: ParsecT String u Identity SM.Expression
sExpression = ann SExpression (char '(' *> many sExpressionItem <* char ')')

infixSExpression :: ParsecT String u Identity SM.Expression
infixSExpression =
  ann
    SExpression
    ((Symbol AutoGenerated "applyInfix" :) <$>
     (char '{' *> many sExpressionItem <* char '}'))

spliceUnquotedExpression :: ParsecT String u Identity SM.Expression
spliceUnquotedExpression = parseReadMacro "~@" "unquoteSplicing"

symbol :: (Stream s Identity Char) => ParsecT s u Identity SM.Expression
symbol =
  ann
    Symbol
    (many1
       (alphaNum <|> oneOf "'_" <|>
        oneOf (map fst haskellSyntaxSymbols \\ syntaxSymbols) <|>
        oneOf (map fst haskellOperatorSymbols)))

unquotedExpression :: ParsecT String u Identity SM.Expression
unquotedExpression = parseReadMacro "~" "unquote"

expression :: ParsecT String u Identity SM.Expression
expression =
  literalChar <|> literalInt <|> literalList <|> literalString <|>
  quotedExpression <|>
  quasiquotedExpression <|>
  try spliceUnquotedExpression <|>
  unquotedExpression <|>
  sExpression <|>
  infixSExpression <|>
  symbol

parseMultiple ::
     (Member (Effs.Error SM.Error) effs) => String -> Eff effs [SM.Expression]
parseMultiple input =
  case parse
         (many1 (optional whitespace *> expression <* optional whitespace) <*
          eof)
         ""
         input of
    Right exprs -> pure exprs
    Left err -> throwError (ParseError (show err) :: SM.Error)

-- | Will error at runtime if any are true:
--    * A parse error occurs.
--    * Multiple statements were able to be parsed.
unsafeParseSingle :: String -> SM.Expression
unsafeParseSingle = head . unsafeIgnoreError @SM.Error . parseMultiple

stripComments :: String -> String
stripComments = unlines . map cleanLine . lines
  where
    cleanLine = takeUntil "--"

parseSource ::
     (Member (Effs.Error SM.Error) effs) => String -> Eff effs SM.Expression
parseSource input = do
  statements <- parseMultiple $ stripComments input
  pure $ topLevelExpressionsToProgram statements

syntaxSymbols :: String
syntaxSymbols = "()[]{}"
