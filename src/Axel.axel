(pragma "OPTIONS_GHC -Wno-incomplete-patterns")

(module Axel)

(import Axel.Prelude all)
(importq Axel.Parse.AST AST all)
(importq Axel.Sourcemap SM all)
(import Axel.Utils.FilePath (takeFileName))
(import Data.IORef (IORef modifyIORef newIORef readIORef))
(importq Data.Text T all)
(import System.IO.Unsafe (unsafePerformIO))
(import Control.Lens.Cons (snoc))

(=macro applyInfix ([x op y])
        (pure
         [(AST.SExpression
           (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 19 17)))
           (concat [[op] [x] [y]]))]))

(=macro defmacro ({name : cases})
        (pure
         (map
          (\
           ((AST.SExpression _ {args : body}))
           (AST.SExpression
            (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 24 55)))
            (concat
             [['=macro]
              [name]
              [(AST.SExpression
                (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 24 69)))
                (concat [[args]]))]
              (AST.toExpressionList body)])))
          cases)))

(defmacro def
          ({name : {typeSig : cases}}
           (pure
            (snoc
             (map
              (\ (x)
                 (AST.SExpression
                  (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 32 32)))
                  (concat [['=] [name] (AST.toExpressionList x)])))
              cases)
             (AST.SExpression
              (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 34 20)))
              (concat [['::] [name] [typeSig]]))))))

(defmacro syntaxQuote
          ([x]
           (pure
            [(AST.quoteExpression (const (AST.Symbol Nothing "_")) x)])))

(def expandDo' {([] SM.Expression) -> SM.Expression}
     (({(AST.SExpression _ [(syntaxQuote <-) var val]) : rest})
      (AST.SExpression
       (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 45 8)))
       (concat
        [['>>=]
         [val]
         [(AST.SExpression
           (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 45 18)))
           (concat
            [['\]
             [(AST.SExpression
               (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 45 21)))
               (concat [[var]]))]
             [(expandDo' rest)]]))]])))
     (({(AST.SExpression _ {(syntaxQuote let) : bindings}) : rest})
      (AST.SExpression
       (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 47 8)))
       (concat
        [['let]
         [(AST.SExpression
           (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 47 13)))
           (concat [(AST.toExpressionList bindings)]))]
         [(expandDo' rest)]])))
     (({val : rest})
      (case rest
            ([] val)
            (_ (AST.SExpression
                (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 51 13)))
                (concat [['>>] [val] [(expandDo' rest)]]))))))

(defmacro do' (input (pure [(expandDo' input)])))

(def gensymCounter (IORef Int)
     (() (unsafePerformIO (newIORef 0))))

(pragma "NOINLINE gensymCounter")

(def gensym (IO SM.Expression)
     (()
      (do'
       (<- suffix (readIORef gensymCounter))
       (let (identifier
             {"aXEL_AUTOGENERATED_IDENTIFIER_" <> (showText suffix)}))
       (modifyIORef gensymCounter succ)
       (pure (AST.Symbol Nothing (T.unpack identifier))))))

(defmacro \case
          (cases
           (fmap
            (\
             (varId)
             [(AST.SExpression
               (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 70 15)))
               (concat
                [['\]
                 [(AST.SExpression
                   (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 70 18)))
                   (concat [[varId]]))]
                 [(AST.SExpression
                   (GHCPrelude.Just (, "src/Axel.axel" (SM.Position 70 27)))
                   (concat [['case] [varId] (AST.toExpressionList cases)]))]]))])
            gensym)))

(def isPrelude {FilePath -> Bool}
     (() {(== (FilePath "Axel.axel")) . takeFileName}))

(def preludeMacros ([] Text)
     (()
      ["applyInfix" "defmacro" "def" "do'" "\\case" "syntaxQuote"]))
