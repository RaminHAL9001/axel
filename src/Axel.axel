(pragma "OPTIONS_GHC -Wno-incomplete-patterns")

(module Axel)

(import Axel.Prelude all)

(import Axel.Parse (hygenisizeIdentifier))
(importq Axel.Sourcemap SM all)
(import Axel.Utils.FilePath (takeFileName))

(import Data.IORef (IORef modifyIORef newIORef readIORef))
(importq Data.Text T all)

(import System.IO.Unsafe (unsafePerformIO))

(=macro applyInfix ([x op y])
        (pure [`(~op ~x ~y)]))

-- Macros only ever take one argument, so we can reduce some redundancy.
(=macro defmacro ({name : cases})
        (pure
         (map (\ ((AST.SExpression _ {args : body})) `(=macro ~name (~args) ~@body))
              cases)))

(defmacro def
    ({name : {typeSig : cases}}
           (pure
            (: `(:: ~name ~@typeSig)
               (map (\ ((AST.SExpression _ {args : xs})) `(= (~name ~@args) ~@xs))
                    cases)))))

(def if (() {Bool -> {a -> {a -> a}}})
     ((True x _) x)
     ((False _ x) x))

(defmacro syntaxQuote
    ([x]
     (pure
      [(AST.quoteExpression
        (const (AST.Symbol Nothing "_"))
        x)])))

(def expandDo (() {([] SM.Expression) -> SM.Expression})
     (({(AST.SExpression _ [(syntaxQuote <-) var val]) : rest})
      `(>>= ~val (\ (~var) ~(expandDo rest))))
     (({(AST.SExpression _ {(syntaxQuote let) : bindings}) : rest})
      `(let (~@bindings) ~(expandDo rest)))
     (({val : rest})
      (case rest
        ([] val)
        (_ `(>> ~val ~(expandDo rest))))))

(defmacro do
    (input (pure [(expandDo input)])))

(def gensymCounter (() (IORef Int))
     (() (unsafePerformIO (newIORef 0))))
(pragma "NOINLINE gensymCounter")

(def gensym (() (IO SM.Expression))
     (() (do
          (<- suffix (readIORef gensymCounter))
          (let (identifier {"aXEL_AUTOGENERATED_IDENTIFIER_" <> (showText suffix)}))
          (modifyIORef gensymCounter succ)
          (pure (AST.Symbol Nothing (T.unpack identifier))))))

(defmacro \case
    (cases
     (fmap (\ (varId)
            [`(\ (~varId) (case ~varId ~@cases))])
           gensym)))

-- TODO Automatically derive this somehow(?)
(def isPrelude (() {FilePath -> Bool})
     (()
      {(== (FilePath "Axel.axel")) . takeFileName}))

-- TODO Automatically generate this (wrap the whole file with a macro that finds all macro definitions and creates this list?)
(def preludeMacros (() ([] Text)) (() (map {T.pack . hygenisizeIdentifier} ["applyInfix" "defmacro" "def" "do" "\\case" "syntaxQuote"])))
