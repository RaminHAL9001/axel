(pragma "OPTIONS_GHC -Wno-incomplete-patterns")

(module Axel)

(importq Axel.Parse.AST AST all)

(import Control.Lens.Cons (snoc))

(=macro quote ([x]) (pure [(AST.quoteParseExpression x)]))

-- Algorithm adapted from the one detailed in the Common Lisp HyperSpec.
(=macro quasiquote ([(AST.SExpression ann xs)])
        (let ((quasiquoteElem (\ (x) (case x
                                       ((AST.SExpression ann' [(AST.Symbol _ "unquote") expr])
                                        (AST.SExpression ann' ['list expr]))
                                       ((AST.SExpression ann' [(AST.Symbol _ "unquoteSplicing") expr])
                                        (AST.SExpression ann' ['AST.toExpressionList expr]))
                                       (atom
                                        (AST.SExpression ann
                                         ['list
                                          (AST.SExpression ann ['quasiquote atom])]))))))
          (pure [(AST.SExpression ann
                  ['AST.SExpression 'AST.AutoGenerated
                   (AST.SExpression ann
                    ['concat
                     (AST.SExpression ann
                      (: 'list
                         (map quasiquoteElem xs)))])])])))
(=macro quasiquote ([atom])
        (pure [(AST.SExpression AST.AutoGenerated ['quote atom])]))

(=macro applyInfix ([x op y])
        (pure [`(~op ~x ~y)]))

-- Macros only ever take one argument, so we can reduce some redundancy.
(=macro defmacro ({name : cases})
        (pure
         (map (\ ((AST.SExpression _ {args : body})) `(=macro ~name (~args) ~@body))
              cases)))

-- The type signature must come after so that macro inside the function body
-- don't complain about the function not being defined.
(defmacro def
  ({name : {typeSig : cases}}
   (pure
    (snoc (map (\ (x) `(= ~name ~@x))
               cases)
          `(:: ~name ~typeSig)))))

(defmacro \case
  (cases
   (fmap (\ (varId)
            [`(\ (~varId) (case ~varId ~@cases))])
         AST.gensym)))

(=macro syntaxPattern ([pattern])
  (pure
   [(AST.bottomUpFmap
     (\ (expr)
        (case expr
          ((AST.SExpression _ [(AST.Symbol fnHeadAnn fnHead) _ x])
           (if {fnHead elem exprConstructors}
             (AST.SExpression AST.AutoGenerated [(AST.Symbol fnHeadAnn fnHead) '_ x])
             expr))
          (_ expr)))
     pattern)])
   (= exprConstructors () ["AST.LiteralChar" "AST.LiteralInt" "AST.LiteralString" "AST.SExpression" "AST.Symbol"])) -- TODO `dataTypeRep` and all that jazz

-- TODO Rewrite with `syntaxPattern`.
(def expandDo' {[(AST.Expression AST.SourceMetadata)] -> (AST.Expression AST.SourceMetadata)}
  ((syntaxPattern ({var : {'<- : {val : rest}}}))
   `(>>= ~val (\ (~var) ~(expandDo' rest))))
  (({val : rest})
   (case rest
     ([] val)
     (_ `(>> ~val ~(expandDo' rest))))))

(defmacro do'
  (input (pure [(expandDo' input)])))
