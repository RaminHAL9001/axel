{-# OPTIONS_GHC -Wno-incomplete-patterns #-}
module Axel where
import qualified Axel.Parse.AST as AST
import Control.Lens.Cons (snoc)
expandDo'
  ((:) var ((:) (AST.Symbol AST.AutoGenerated "<-") ((:) val rest)))
  = (AST.SExpression AST.AutoGenerated
       (concat
          [[(AST.Symbol AST.AutoGenerated ">>=")], [val],
           [(AST.SExpression AST.AutoGenerated
               (concat
                  [[(AST.Symbol AST.AutoGenerated "\\")],
                   [(AST.SExpression AST.AutoGenerated (concat [[var]]))],
                   [(expandDo' rest)]]))]]))
expandDo' ((:) val rest)
  = (case rest of
         [] -> val
         _ -> (AST.SExpression AST.AutoGenerated
                 (concat
                    [[(AST.Symbol AST.AutoGenerated ">>")], [val],
                     [(expandDo' rest)]])))

expandDo' ::
          ((->) [(AST.Expression AST.SourceMetadata)]
             (AST.Expression AST.SourceMetadata))
quasiquote [(AST.SExpression _ xs)]
  = (let quasiquoteElem
           = (\ x ->
                (case x of
                     (AST.SExpression _
                        [(AST.Symbol AST.AutoGenerated "unquote"),
                         expr]) -> (AST.SExpression AST.AutoGenerated
                                      [(AST.Symbol AST.AutoGenerated "list"), expr])
                     (AST.SExpression _
                        [(AST.Symbol AST.AutoGenerated "unquoteSplicing"),
                         expr]) -> (AST.SExpression AST.AutoGenerated
                                      [(AST.Symbol AST.AutoGenerated "AST.toExpressionList"), expr])
                     atom -> (AST.SExpression AST.AutoGenerated
                                [(AST.Symbol AST.AutoGenerated "list"),
                                 (AST.SExpression AST.AutoGenerated
                                    [(AST.Symbol AST.AutoGenerated "quasiquote"), atom])])))
       in
       (pure
          [(AST.SExpression AST.AutoGenerated
              [(AST.Symbol AST.AutoGenerated "AST.SExpression"),
               (AST.Symbol AST.AutoGenerated "AST.AutoGenerated"),
               (AST.SExpression AST.AutoGenerated
                  [(AST.Symbol AST.AutoGenerated "concat"),
                   (AST.SExpression AST.AutoGenerated
                      ((:) (AST.Symbol AST.AutoGenerated "list")
                         (map quasiquoteElem xs)))])])]))
quasiquote [atom]
  = (pure
       [(AST.SExpression AST.AutoGenerated
           [(AST.Symbol AST.AutoGenerated "quote"), atom])])
applyInfix [x, op, y]
  = (pure
       [(AST.SExpression AST.AutoGenerated (concat [[op], [x], [y]]))])
defmacro ((:) name cases)
  = (pure
       (map
          (\ x ->
             (AST.SExpression AST.AutoGenerated
                (concat
                   [[(AST.Symbol AST.AutoGenerated "=macro")], [name],
                    (AST.toExpressionList x)])))
          cases))
def ((:) name ((:) typeSig cases))
  = (pure
       (snoc
          (map
             (\ x ->
                (AST.SExpression AST.AutoGenerated
                   (concat
                      [[(AST.Symbol AST.AutoGenerated "=")], [name],
                       (AST.toExpressionList x)])))
             cases)
          (AST.SExpression AST.AutoGenerated
             (concat
                [[(AST.Symbol AST.AutoGenerated "::")], [name], [typeSig]]))))
fnCase cases
  = ((<$>)
       (\ varId ->
          [(AST.SExpression AST.AutoGenerated
              (concat
                 [[(AST.Symbol AST.AutoGenerated "\\")],
                  [(AST.SExpression AST.AutoGenerated (concat [[varId]]))],
                  [(AST.SExpression AST.AutoGenerated
                      (concat
                         [[(AST.Symbol AST.AutoGenerated "case")], [varId],
                          (AST.toExpressionList cases)]))]]))])
       AST.gensym)
do' input = (pure [(expandDo' input)])

quasiquote :: ((->) ([] AST.Expression) (IO ([] AST.Expression)))

applyInfix :: ((->) ([] AST.Expression) (IO ([] AST.Expression)))

defmacro :: ((->) ([] AST.Expression) (IO ([] AST.Expression)))

def :: ((->) ([] AST.Expression) (IO ([] AST.Expression)))

fnCase :: ((->) ([] AST.Expression) (IO ([] AST.Expression)))

do' :: ((->) ([] AST.Expression) (IO ([] AST.Expression)))