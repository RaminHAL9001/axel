{-# LANGUAGE FlexibleContexts #-}

{-
The below module is most definitely a Work In Progress. Yay!

Macros edit the parse tree, which the compiler converts to an AST which is transpiled into Eta.
1. When macros are expanded, the code forms passed in as its arguments are represented as a list of parse expressions (lists, symbols, literals, etc.).
   The output of the macro programs is rendered as a list and inserted back into the file.
2. Step 1 is repeated until no more macros are available for expansion.
3. The whole file is then tranpsiled into Eta as usual.

MACRO EXPANSION STRATEGY
This is just a very, very rough hypothesis. It's probably broken, and I have no idea how it would be adapted to work with macros defined in multiple files or mutually-recursive macros (or even self-recursive macros). You have been warned.
I'm assuming macros should be expanded inner-to-outer (since Lisps let allow for using macros inside macros, e.g. `with-gensyms` and its ilk).
1. Read the file top-to-bottom, collecting macro definitions.
   For each macro definition, check if already-defined macros are being used inside the definition. If so, expand their usages and repeat until there are no macro usages left in each definition.
2. Expand the deepest macro usages inside each non-`defmacro` expression. Repeat until there are no macro usages left.
-}
module Lihsp.Macros where

import Control.Lens.Operators ((&), (.~))
import Control.Monad.Except (MonadError, throwError)
import Control.Monad.IO.Class (MonadIO, liftIO)

import Data.Semigroup ((<>))

import Lihsp.AST (MacroDefinition, name)
import Lihsp.Error (Error(MacroError))
import qualified Lihsp.Parse as Parse (Expression)
import Lihsp.Parse (parseProgram)

import Paths_lihsp (getDataFileName)

import System.Directory (getTemporaryDirectory, removeFile)
import System.Exit (ExitCode(ExitFailure, ExitSuccess))
import System.IO (Handle, hClose, hPutStr, openTempFile)
import System.Process (readProcessWithExitCode)

withTempFile :: (MonadIO m) => FilePath -> (FilePath -> Handle -> m a) -> m a
withTempFile template f = do
  temporaryDirectory <- liftIO getTemporaryDirectory
  (fileName, handle) <- liftIO $ openTempFile temporaryDirectory template
  result <- f fileName handle
  liftIO $ hClose handle
  liftIO $ removeFile fileName
  return result

generateMacroProgram :: MacroDefinition -> IO String
generateMacroProgram macroDefinition = do
  let macroSource = macroDefinition & name .~ "aUTOGENERATED_MACRO_FUNCTION"
  footer <- getDataFileName "resources/macros/Footer.hs" >>= readFile
  header <- getDataFileName "resources/macros/Header.hs" >>= readFile
  return $ header <> show macroSource <> footer

execInterpreter :: (MonadError Error m, MonadIO m) => FilePath -> m String
execInterpreter fileName = do
  (code, stdout, stderr) <-
    liftIO $ readProcessWithExitCode "runhaskell" [fileName] ""
  case code of
    ExitSuccess -> return stdout
    ExitFailure _ -> throwError $ MacroError stderr

runMacro ::
     (MonadError Error m, MonadIO m) => MacroDefinition -> m [Parse.Expression]
runMacro macroSource =
  withTempFile "TempMacro.hs" $ \fileName handle -> do
    macroProgram <- liftIO $ generateMacroProgram macroSource
    liftIO $ hPutStr handle macroProgram
    result <- execInterpreter fileName
    parseProgram result
