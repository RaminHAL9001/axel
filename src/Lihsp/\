{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}

module Lihsp.Macros where

import Control.Lens.Operators ((^.))
import Control.Monad.Except (MonadError, throwError)
import Control.Monad.IO.Class (MonadIO, liftIO)

import Data.List (foldl')
import Data.Semigroup ((<>))

import Lihsp.AST
  ( MacroDefinition
  , Statement(SMacroDefinition)
  , ToHaskell(toHaskell)
  , definitions
  , name
  )
import Lihsp.Error (Error(MacroError))
import Lihsp.Eval (evalSource)
import qualified Lihsp.Parse as Parse
  ( Expression(LiteralChar, LiteralInt, LiteralString, SExpression,
           Symbol)
  , parseProgram
  )
import Lihsp.Utils.Recursion (Recursive(bottomUpTraverse))
import Lihsp.Utils.Resources (readDataFile)
import Lihsp.Utils.String (replace)

generateMacroProgram ::
     (MonadIO m) => MacroDefinition -> [Parse.Expression] -> m String
generateMacroProgram macroDefinition applicationArguments =
  (<>) <$> liftIO getFileHeader <*> liftIO getFileFooter
  where
    getFileHeader = readDataFile "autogenerated/macros/Header.hs"
    getFileFooter =
      let insertApplicationArguments =
            let applicationArgumentsPlaceholder = "%%%ARGUMENTS%%%"
            in replace
                 applicationArgumentsPlaceholder
                 (show applicationArguments)
          insertDefinitionBody =
            let definitionBodyPlaceholder = "%%%MACRO_DEFINITION%%%"
            in replace definitionBodyPlaceholder (toHaskell macroDefinition)
          insertDefinitionName =
            let definitionNamePlaceholder = "%%%MACRO_NAME%%%"
            in replace definitionNamePlaceholder (macroDefinition ^. name)
      in insertApplicationArguments .
         insertDefinitionName . insertDefinitionBody <$>
         readDataFile "macros/Footer.hs"

expandMacros ::
     (MonadError Error m, MonadIO m)
  => [MacroDefinition]
  -> Parse.Expression
  -> m Parse.Expression
expandMacros environment =
  bottomUpTraverse $ \expression ->
    case expression of
      Parse.LiteralChar _ -> return expression
      Parse.LiteralInt _ -> return expression
      Parse.LiteralString _ -> return expression
      Parse.SExpression functionApplication ->
        lookupMacroDefinition environment (head functionApplication) >>= \case
          Just macroDefinition ->
            head <$>
            expandMacroApplication macroDefinition (tail functionApplication)
          Nothing -> return expression
      Parse.Symbol _ -> return expression
  where
    expandMacroApplication macroDefinition args =
      generateMacroProgram macroDefinition args >>= evalSource >>=
      Parse.parseProgram

lookupMacroDefinition ::
     (MonadError Error m)
  => [MacroDefinition]
  -> Parse.Expression
  -> m (Maybe MacroDefinition)
lookupMacroDefinition environment identifierExpression =
  case identifierExpression of
    Parse.LiteralChar _ -> return Nothing
    Parse.LiteralInt _ -> return Nothing
    Parse.LiteralString _ -> return Nothing
    Parse.SExpression _ -> return Nothing
    Parse.Symbol identifier ->
      case filter
             (\macroDefinition -> macroDefinition ^. name == identifier)
             environment of
        [] -> return Nothing
        [macroDefinition] -> return $ Just macroDefinition
        _ -> throwError (MacroError "0012")

-- TODO This probably needs heavy optimization. If so, decrease the running time.
extractMacroDefinitions :: [Statement] -> [MacroDefinition]
extractMacroDefinitions = foldl' handleStatement []
  where
    handleStatement :: [MacroDefinition] -> Statement -> [MacroDefinition]
    handleStatement env statement =
      case statement of
        SMacroDefinition macroDefinition ->
          let newEnv = macroDefinition : env
          in filter (not . isDependentOnEnv newEnv) newEnv
        _ -> env
    isDependentOnEnv :: [MacroDefinition] -> MacroDefinition -> Bool
    isDependentOnEnv env macroDefinition =
      any (`isDefinitionDependentOnMacro` macroDefinition) env
    isDefinitionDependentOnMacro :: MacroDefinition -> MacroDefinition -> Bool
    isDefinitionDependentOnMacro needle haystack =
      any
        (\case
            _ -> undefined)
        (haystack ^. definitions)
