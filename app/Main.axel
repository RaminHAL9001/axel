(pragma "LANGUAGE DataKinds")
(pragma "LANGUAGE TypeApplications")
(module Main)
(raw "import Prelude hiding (putStrLn)")
(import Axel.Eff.Console (putStrLn))
(importq Axel.Eff.Console Effs (Console))
(importq Axel.Eff.Console Console (runEff))
(importq Axel.Eff.FileSystem FS (runEff))
(importq Axel.Eff.FileSystem Effs (FileSystem))
(importq Axel.Eff.Ghci Ghci (runEff))
(importq Axel.Eff.Ghci Effs (Ghci))
(importq Axel.Eff.Log Log (ignoreEff))
(importq Axel.Eff.Log Effs (Log))
(importq Axel.Eff.Process Proc (runEff))
(importq Axel.Eff.Process Effs (Process))
(importq Axel.Eff.Resource Res (runEff))
(importq Axel.Eff.Resource Effs (Resource))
(importq Axel.Error Error (Error unsafeRunEff))
(import Axel.Haskell.File (convertFile' transpileFile'))
(import Axel.Haskell.Project (buildProject runProject))
(import Axel.Haskell.Stack (axelStackageVersion))
(import Axel.Macros (ModuleInfo))
(import Axel.Parse.Args ((Command Convert File Project Version) commandParser))
(import Control.Monad (void))
(import Control.Monad.Freer (Eff))
(importq Control.Monad.Freer Effs (runM))
(importq Control.Monad.Freer.Error Effs (Error))
(import Control.Monad.Freer.State (evalState))
(importq Data.Map Map (empty))
(import Options.Applicative (<**> execParser helper info progDesc))
(type AppEffs (Eff (raw "'[Effs.Log, Effs.Console, Effs.Error Error.Error, Effs.FileSystem, Effs.Ghci, Effs.Process, Effs.Resource, IO]")))
(def runApp ((-> (AppEffs a)) (IO a)) (() (. Effs.runM (. Res.runEff (. Proc.runEff (. Ghci.runEff (. FS.runEff (. Error.unsafeRunEff (. Console.runEff Log.ignoreEff)))))))))
(def app ((-> Command) (AppEffs Unit)) (((Convert filePath)) (void (convertFile' filePath))) (((File filePath)) (void ((evalState (raw "@ModuleInfo") Map.empty) (transpileFile' filePath)))) (((Project)) (>> buildProject runProject)) (((Version)) (putStrLn (<> "Axel version " axelStackageVersion))))
-- (def main (IO Unit) (() (raw "do { modeCommand <- execParser $ info (commandParser <**> helper) (progDesc \\\"The command to run.\\\"); runApp $ app modeCommand}")))
(def main (IO Unit)
 (()
  (do'
   {modeCommand <- (execParser (info {commandParser <*>> helper} (progDesc "The command to run.")))}
   (runApp modeCommand))))