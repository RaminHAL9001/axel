(pragma "LANGUAGE DataKinds")
(pragma "LANGUAGE TypeApplications")
(module Main)
(importm Axel {def defmacro fnCase mdo quasiquote})
(import Axel (applyInfix_AXEL_AUTOGENERATED_MACRO_DEFINITION def_AXEL_AUTOGENERATED_MACRO_DEFINITION defmacro_AXEL_AUTOGENERATED_MACRO_DEFINITION fnCase_AXEL_AUTOGENERATED_MACRO_DEFINITION mdo_AXEL_AUTOGENERATED_MACRO_DEFINITION quasiquote_AXEL_AUTOGENERATED_MACRO_DEFINITION))
(raw "import Prelude hiding (putStrLn)")
(import Axel.Eff.Console (putStrLn))
(importq Axel.Eff.Console Effs (Console))
(importq Axel.Eff.Console Console (runEff))
(importq Axel.Eff.FileSystem FS (runEff))
(importq Axel.Eff.FileSystem Effs (FileSystem))
(importq Axel.Eff.Ghci Ghci (runEff))
(importq Axel.Eff.Ghci Effs (Ghci))
(importq Axel.Eff.Process Proc (runEff))
(importq Axel.Eff.Process Effs (Process))
(importq Axel.Eff.Resource Res (runEff))
(importq Axel.Eff.Resource Effs (Resource))
(import Axel.Error (Error))
(importq Axel.Error Error (runEff))
(import Axel.Haskell.File (convertFile' transpileFile'))
(import Axel.Haskell.Project (buildProject runProject))
(import Axel.Haskell.Stack (axelStackageVersion))
(import Axel.Macros (ModuleInfo))
(import Axel.Parse.Args ((Command Convert File Project Version) commandParser))
(import Control.Monad (void))
(import Control.Monad.Freer (Eff))
(importq Control.Monad.Freer Effs (runM))
(importq Control.Monad.Freer.Error Effs (Error))
(import Control.Monad.Freer.State (evalState))
(importq Data.Map Map (empty))
(import Options.Applicative (<**> execParser helper info progDesc))
(type AppEffs (Eff (raw "'[Effs.Console, Effs.Error (Error ann), Effs.FileSystem, Effs.Ghci, Effs.Process, Effs.Resource, IO]")))
(def runApp ((-> (AppEffs a)) (IO a)) (() (. Effs.runM (. Res.runEff (. Proc.runEff (. Ghci.runEff (. FS.runEff (. Error.runEff Console.runEff))))))))
(def app ((-> Command) (AppEffs Unit)) (((Convert filePath)) (void (convertFile' filePath))) (((File filePath)) (void ((evalState (raw "@ModuleInfo") Map.empty) (transpileFile' filePath)))) (((Project)) (>> buildProject runProject)) (((Version)) (putStrLn (<> "Axel version " axelStackageVersion))))
(def main (IO Unit) (() (raw "do { modeCommand <- execParser $ info (commandParser <**> helper) (progDesc \\\"The command to run.\\\"); runApp $ app modeCommand}")))
