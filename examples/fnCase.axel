-- NOTE This will eventually be automatically defined by the Axel prelude.
(defmacro if
  (([cond true false])
   (pure [`(case ~cond
             (True ~true)
             (False ~false))])))

-- NOTE This will eventually be automatically defined by the Axel prelude.
(defmacro quasiquote
  (([(AST.SExpression xs)])
   (let ((quasiquoteElem (fn (x) (case x
                                   ((AST.SExpression ['unquote x])
                                    (AST.SExpression ['list x]))
                                   ((AST.SExpression ['unquoteSplicing x])
                                    x)
                                   (atom
                                    (AST.SExpression
                                     ['list
                                      (AST.SExpression ['quasiquote atom])]))))))
     (pure [(AST.SExpression ['AST.SExpression (AST.SExpression ['concat (AST.SExpression (: 'list (map quasiquoteElem xs)))])])])))
  (([atom]) (pure [(AST.SExpression ['quote atom])])))

-- NOTE This will eventually be automatically defined by the Axel prelude.
(= do' (-> ([] AST.Expression) AST.Expression)
   (() (fnCase
        ((: var (: '<- (: val rest)))
         `(>>= ~val (fn (~var) ~(do' rest))))
        ((: val rest)
         (case rest
           ([]
            val)
           (_
            `(>> ~val ~(do' rest))))))))
(defmacro do
  ((input)
   (pure [(do' input)])))

(defmacro fnCase
  ((cases)
   (do
     varId <- AST.gensym
     (pure [`(fn (~varId) (case ~varId ~@cases))]))))

(= main (IO Unit)
   (() ((fnCase
         ("tada" (putStrLn "ðŸŽ‰"))
         (_ (putStrLn "Impossible!")))
        "tada")))
