(importq Axel.Parse.AST AST all)

-- NOTE This will eventually be automatically defined by the Axel prelude.
(macro quasiquote ([(AST.SExpression xs)])
       (let ((quasiquoteElem (\ (x) (case x
                                      ((AST.SExpression ['unquote x])
                                       (AST.SExpression ['list x]))
                                      ((AST.SExpression ['unquoteSplicing x])
                                       (AST.SExpression ['AST.toExpressionList x]))
                                      (atom
                                       (AST.SExpression
                                        ['list
                                         (AST.SExpression ['quasiquote atom])]))))))
         (pure [(AST.SExpression ['AST.SExpression (AST.SExpression ['concat (AST.SExpression (: 'list (map quasiquoteElem xs)))])])])))
(macro quasiquote ([atom])
       (pure [(AST.SExpression ['quote atom])]))

-- NOTE This will eventually be automatically defined by the Axel prelude.
(macro fnCase (cases)
       (<$> (\ (varId)
             [`(\ (~varId) (case ~varId ~@cases))])
            AST.gensym))

-- NOTE This will eventually be automatically defined by the Axel prelude.
(macro def ((: name (: typeSig cases)))
       (pure
        (: `(:: ~name ~typeSig)
           (map (\ (x) `(= ~name ~@x))
                cases))))

-- NOTE This will eventually be automatically defined by the Axel prelude.
(macro if ([cond true false])
       (pure [`(case ~cond
                 (True ~true)
                 (False ~false))]))

(def main (IO Unit)
  (()
   (putStrLn
    (if (== 1 1) "Correct!" "Impossible..."))))
